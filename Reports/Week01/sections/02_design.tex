The processes used to design the Controller and their results will be now
described.

\section{Bad system identification and consequent wrong motor controller}

  The first month of work on this last part of the project lead to the
  design and development of a controller based on a digital controller for
  the motors that was not working correctly.

  The Controller was the following:

  \begin{align}\label{eqn:OldWallController}
    C(s) = K_c \cdot{} \frac{(s + z_1) \cdot{} (s + z_2)}{(s + p_1) \cdot{} (s + p_2)}
  \end{align}

  With $K_c = 600$, $z_1 = 2$, $z_2 = 2.3$, $p_1 = 15$ and $p_2 = 20$. 

  Even though the controller in the simulations was correct and behaved
  correctly, as shown in figures \ref{Img:OWCRL} and \ref{Img:OWCResp},
  once implemented on the plataform it was disappointing to say the least.

  \begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{Images/OldWallController.pdf}
    \caption{The Evans Root Locus for the Old Version of the Controller
    \ref{eqn:OldWallController}\label{img:OWCRL}}
  \end{figure}

  \begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{Images/OldWallControllerResp.pdf}
    \caption{The Response of the discretized controller (With a period of
      50 ms) when required to get to 0.4
      meters ``away'' from an ideal wall.\label{img:OWCResp}}
  \end{figure}


  The behaviour of the veichle was unpredictable and, in the best cases,
  simply crashed into the wall or went away from it.

  This lead to a series of hypothesis on the causes of this behaviour.

  Those that were taken in account were:

  \begin{itemize}
    \item{} Numerical Instability
    \item{} Wrong distance computation
    \item{} Wrong motors' behaviour, and, more specifically, bad digital
      controller design
    \item{} Wrong distance computation / controller period
  \end{itemize}

  Eventually was discovered that the motor controller was not working good
  enough under pressure and that that it needed to be redesigned.

\section{New parameters for the motors and new digital controller}

  The main problem of the controller was that it was designed to work
  against a motor with given parameters, but these parameters were not
  correct. This was due to the fact that we computed using data from motors
  activaded with their brakes off.

  This might sound strange, but the motors, activated with the ``brake''
  flag on, behave in a way that is much better that when this flag is
  deactivated. This is given by their design. Since the speed of the \nxt{}
  motors is controlled via \newterm{PWM (Pulse Wave modulation)}, then the
  ``brake'' flag indicates how are the motors controlled during the
  ``zero'' phase of the PWM.

  However, after a batch of tests (Such as the ones in \ref{img:45_65_100},
  three new values for $\xi$, $\omega_n$ and $K_p$ were computed:

  \begin{align}\label{eqn:newXiWn}
    \xi &= 0.912 \\
    \omega_n &= 10.346 \\
    K_p &= 8.1
  \end{align}
 
  \begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{Images/45_65_100_Step.pdf}
    \caption{Behaviour of the motors when given in input a power of 45\%
    (in Blue), 65\% (in Green) and 100\% (in Red)\label{img:45_65_100}}
  \end{figure}

  After that a new controller was designed with simplicity in mind, so it
  was developed using only one zero and one pole in $0$:

  \begin{align}\label{eqn:LMController}
    C(s) &= K_c \cdot \frac{s + z1}{s} \\
    C(s) &= K_c \cdot (\frac{z1}{s} + 1)
  \end{align}


  The controller, even if simple, was splitted in order to implement an
  Anti-Windup system.

  The new controller was then implemented in SciCosLab (Image
  \ref{img:LiberaMeC}) and then was implemented and tested on the \nxt{}.
  
  \begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{Images/LiberaMe_NewMotor.png}
    \caption{Model of the New Controller in Scicos \label{img:LiberaMeC}}
  \end{figure}


\section{Target parameters for the Wall Following Controller}

  \subsection{Computing the target $\xi$ and $\omega_n$}
  Since the system is required to behave according to our needs we had to
  compute the values for $\xi$ (Dampening Factor) and $\omega_n$
  (Natural Frequency). The target values for Raising Time ($T_r$), Settling
  Time ($T_s$) and Overshoot ($M_p$) were:
  
  \graffito{Target parameters}
  \begin{itemize}
    
    \item{} $T_r = 3s$
    \item{} $T_s = 6s$
    \item{} $M_p = 0.1$

  \end{itemize}
  
  To compute these values the same equations as the ones shown in the
  second report were used, reaching $\xi = 0.591$ and $\omega_n = 0.6$.

  \subsection{The need of high Raise Time and distance computation}

    To compute the correct distance from the wall it was decided to use two
    ultrasonic sensors, distant $S_d$ between them, which get two different
    distances at the same time, $D_0$ and $D_1$ (as shown in figure
    \ref{img:DistanceC}).
    
    \begin{figure}[h!]
      \centering
      \includegraphics[width=\textwidth]{Images/DistanceComputation.pdf}
      \caption{Theoretic Model for computing the distance of the veichle
        from the wall \label{img:DistanceC}}
    \end{figure}
    
    To get the correct distance from the wall we have to compute the angle
    of impact of the two sensors, $\theta$, and then muliplythe first
    distance by its sine:

    \begin{align}
      \tan{\theta} &= \frac{S_d}{\Abs{D_0 - D_1}} \\
      \theta &= \arctan{\frac{S_d}{\Abs{D_0 - D_1}}} \\
      D_v &= D_0 \cdot \sin{\theta}
    \end{align}

    This way of computing the distance could, in theory, work with every
    angle between $0$ and $90$ degrees (extremes not included). The problem
    is that the \nxt{} ultrasonic distance sensors have a limited angle
    range in which they work correctly, since the way they compute the
    distance is done by measuring the time taken to bounce on a surface and
    get back to the sensor.

    This angle is circa $30$ degrees, beyond which the ultrasonic wave
    bouces off the wall and doesn't get back to the sensor, resulting in a
    wrong distance computation (normally this distance is $255 cm$, which
    is the maximum distance that the sonar can read.

    Due to this limitation the raising time of the controller needed to be
    not to small, to get an approach angle towards the wall that was inside
    the working range of the sensors. To do that the raise time was limited
    to $3 sec$ and the safe initial working distance was set to $0.30 m$
    away from the target. Since in that time our wehicle will move for $3 sec \cdot
    31 \frac{m}{sec} = 0.93 m$, then the angle of the sensors towards the
    wall will be $\arccos{\frac{0.30}{0.93}} \simeq 70 deg$
    \label{eqn:MathDist}.


\section{Designing the Continuous time Controller via the Root Locus
    Graphical Method}

  The next step was to design a Closed Loop Transfer function which,
  convoluted with the linearisation of the distance equation (see
  \ref{eqn:DistanceModel}), had to make the vehicle behave as needed.

  The method used to design such controller was the same as the one used
  before for the motors, so it will be omitted.

  The target Controller was designed to have only one pole and one zero, so
  it had this form:

  \begin{align}
    C(s) = K_{cw} \cdot \frac{s + z_1}{s + p_1}
  \end{align}

  The pole in zero was not needed since the transfer function we used to
  model the distance from the wall had the following form:

  \begin{align}\label{eqn:DistanceModel}
    P(s) = \frac{Vel}{s^2}
  \end{align}

  Since it already had two poles in $0$ it was not necessary to add
  another one in the controller. The parameter $Vel$ in the equation is the
  linear speed of the vehicle, which was set to ($r_W$ is the radius of the
  wheels, which is $26 mm$):

  \begin{align}
    Vel &= \pi \cdot r_W \cdot 2 \cdot 1.8 \frac{m}{sec} \\
    Vel &= 0.317 \frac{m}{sec}
  \end{align}

  Since the motors are not perfect and don't reach istantaneously the
  requested speed it was also used the \emph{Pad√© Approximation} of the
  delay to take account of such problem. To do this we multiplied the
  Controller and the Distance Transfer Function by:

  \begin{align}
    Delay = \frac{1 - s \cdot \frac{\tau}{2}}{1 + s \cdot \frac{\tau}{2}}
  \end{align}

  Various values for $p_1$, $z_1$ and $K_{cw}$ were tested and, eventually,
  the Root Locus shown in figure \ref{img:LiberaMeWCRL} was reached, using:

  \begin{align}
    z_1 &= 0.7 \\
    p_1 &= 15 \\
    K_{cw} &= 60
  \end{align}

  \begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{Images/LiberaMeWCRL.pdf}
    \caption{Root Locus analysis for the Wall Controller \label{img:LiberaMeWCRL}}
  \end{figure}
  
\section{Modeling the Controller in Scicoslab}

  Once the values for the controller were found it was implemented in
  Scicos to test if it was actually working, as shown in figure
  \ref{img:LiberaMeWCMod}, and the results were good, as shown in figure
  \ref{img:LiberaMeWCResp}.   

  \begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{Images/LiberaMe_WallController.png}
    \caption{Scicos Model for the Distance Controller
    \label{img:LiberaMeWCMod}}
  \end{figure}

  \begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{Images/LiberaMeWCResp.pdf}
    \caption{Behaviour of the model for the Distance Controller
    \label{img:LiberaMeWCResp}}
  \end{figure}

  \subsection{Additional formulas used to model the Vehicle}

    As can be seen in the model (\ref{img:LiberaMeWCMod}) there are some
    more formulas used to model the vehicle, which are ($r_W$ is the radius
    of the wheels, which is $0.028 m$ and $d_W$ is the distance between
    them, which is $0.12 m$):

    \begin{align}
      Vel &= \frac{\omega_R + \omega_L}{2} \cdot r_W \\
      \omega &= \frac{\omega_R - \omega_L}{d_W} \cdot r_W
    \end{align}

    These are used to compute the linear speed of the vehicle and its
    angular speed, and are used in their inverse form to compute the
    angular speed of the two wheels, once the angular speed of the entire
    vehicle is computed by the controller:

    \begin{align}
      \omega_L &= -\frac{1}{2 r_W} \cdot \left( d_W \cdot \omega - 2Vel
      \right) \\
      \omega_R &= \frac{2Vel}{r_W} - \omega_L
    \end{align}
